# java-calculator-precourse

## 요구사항 정리

* 사용자에게 콘솔에서 정수 문자열을 입력받을 수 있다.
* 사용자에게 입력받은 문자열은 `구분자`에 따라 분할된다.
* 문자열에는 `구분자`와 `양수`만 포함될 수 있다.
* 사용자는 입력 문자열 앞에 `//[구분자]\\n` 형식의 헤더를 추가하여 커스텀 구분자를 등록할 수 있다.
* 올바른 문자열 입력에 따라 얻어진 양수의 합을 반환한다.

## 개발 지향점

* 도메인 모델 객체를 중심으로, 객체의 행위를 메서드를 통해 표현한다.
* Layered Architecture를 통해 **책임별 분리와 방향성 있는 의존 관계**를 유지한다.
* 상위 레이어는 하위 레이어를 의존하지만, 하위 레이어는 상위 레이어를 의존하지 않는다.

## Layer 설정

복잡성이 낮고 외부 연동이 없는 콘솔 기반 프로그램이므로, MVC 구조를 기본으로 한 4계층 형태로 단순화한다.

---

### **View Layer**

* **역할:**
  사용자와의 입출력을 담당한다. 콘솔에서 입력을 읽고 출력한다. `Controller`가 View를 호출해 데이터를 전달받거나 사용자에게 결과를 보여 준다.
* **의존성 방향:**
  `Controller`에 의존하지 않는다. View는 독립 객체로 유지되고, `Controller`가 View를 주입 받아 호출한다.

---

### **Controller Layer**

* **역할:**
  사용자의 요청 흐름을 제어한다. View를 통해 입력을 수집하고 Service에 전달하며, 처리 결과를 다시 View에 위임해 사용자에게 보여 준다.
  예외 발생 시 사용자에게 알맞은 메시지를 출력하거나 애플리케이션 종료를 제어한다.
* **의존성 방향:**
  `View`, `Service`에 의존한다.

---

### **Service Layer**

* **역할:**
  비즈니스 로직의 흐름을 담당한다. 문자열 분리, 커스텀 구분자 처리, 숫자 파싱 및 합산과 같은 기능을 수행한다.
  도메인 모델(`Model`)을 사용하여 연산을 수행하며, 핵심 규칙과 정책을 구현한다.
* **의존성 방향:**
  `Model`에 의존한다.

---

### **Model Layer**

* **역할:**
  핵심 도메인 모델을 정의한다. 비즈니스 규칙을 스스로 보장하며, 불변성과 데이터 무결성을 유지한다.
* **의존성 방향:**
  다른 어떤 레이어에도 의존하지 않는다.

## MVC 구성요소별 흐름

1. `Application`이 `CalculatorController`를 생성하면서 `ConsoleInputView`, `ConsoleOutputView`, `CalculatorService`를 주입하고 `run()`을 호출한다.
2. `Controller`는 주입받은 `ConsoleInputView`를 호출해 문자열을 입력받는다.
3. `Controller`는 입력값을 `CalculatorService`에 전달하고, `Service`는 도메인 모델(`Expression`)을 사용해 합계를 계산한다.
4. `Controller`는 계산 결과를 주입받은 `ConsoleOutputView`에 전달해 사용자에게 출력하도록 위임한다.
5. 도메인 검증 실패 시 발생한 `IllegalArgumentException`은 `Controller`가 메시지를 출력한 뒤 다시 던져 호출 측에서 처리할 수 있게 한다.

## 도메인 모델 책임

모든 도메인 모델은 **불변성**을 유지하고, `Service`가 문자열 계산 규칙을 직접 다루지 않도록 캡슐화를 제공한다. 각 클래스의 기능, 필요성, 내부 참조는 다음과 같다.

* **Expression**
  * 기능: 원시 입력을 헤더와 본문으로 구분하고, `Header`가 제공하는 커스텀 구분자 정보와 기본 구분자를 결합해 `Delimiters`와 `Numbers`를 생성한다.
  * 필요성: `Service`가 문자열 전처리와 검증을 직접 다루지 않고 연산에 집중할 수 있도록 입력 파이프라인을 담당한다.
  * 참조: `Header`, `Delimiters`, `Numbers`를 조합해 최종 합산 대상 숫자 목록을 구성한다.
* **Header**
  * 기능: `//[구분자]\\n` 형식의 접두사를 해석하고, 커스텀 구분자 목록과 본문 문자열을 분리한다.
  * 필요성: 입력 헤더와 본문을 안전하게 구분하고 비정상적인 구분자 선언을 차단해 하위 모델에 정제된 정보를 제공한다.
  * 참조: `Delimiter`를 사용해 개별 커스텀 구분자를 값 객체로 생성하고, `Delimiters`로 전달할 수 있도록 가공한다.
* **Delimiters**
  * 기능: 기본 구분자와 커스텀 구분자를 병합해 정규식 패턴을 생성하고, 본문 문자열을 안전하게 토큰화한다.
  * 필요성: 구분자 정책을 한곳에 모아두고, 외부에서 허용 목록을 임의로 수정하지 못하도록 불변 상태를 보장한다.
  * 참조: 내부적으로 `Delimiter` 값 객체를 보관하며, `Numbers`가 사용할 토큰 분리 로직을 제공한다.
* **Delimiter**
  * 기능: 단일 구분자 문자열을 검증하고 정규식 안전성을 확인한다.
  * 필요성: 커스텀 구분자가 허용 범위를 초과하거나 패턴을 깨뜨리는 것을 사전에 방지한다.
  * 참조: `Delimiters`에 포함되어 토큰 분리에 사용된다.
* **Numbers**
  * 기능: 토큰 문자열을 `PositiveNumber`로 파싱하고 합계를 계산한다.
  * 필요성: 연속 구분자 등으로 발생할 수 있는 빈 토큰을 제거하고, 숫자 검증과 합산을 일관되게 수행한다.
  * 참조: `PositiveNumber` 목록을 보관하며, 계산 결과를 `Controller`에 전달하기 위한 `int` 합계를 제공한다.
* **PositiveNumber**
  * 기능: 문자열을 정수로 변환하고, 음수나 비정상 입력을 차단한다.
  * 필요성: 각 숫자 토큰의 하한을 보장해 전체 합계가 비즈니스 규칙을 준수하도록 한다.
  * 참조: `Numbers`가 개별 토큰을 파싱할 때 사용한다.

## 비즈니스 규칙

* 입력 전체는 `null`이거나 공백일 수 없다.
* 헤더가 존재하면 반드시 `//`로 시작하고 개행(`\n`)으로 종료해야 한다.
* 기본 구분자는 쉼표(`,`), 콜론(`:`)이며, 커스텀 구분자를 추가하면 기본 구분자도 함께 사용된다.
* 커스텀 구분자는 최대 3글자의 알파벳 대/소문자만 허용한다.
* 본문(body)은 비어 있을 수 없고, 허용된 구분자로 분리된 정수 토큰으로 구성되어야 한다.
* 숫자 토큰은 정수여야 하며 음수는 허용되지 않는다. 0은 허용된다.
* 연속된 구분자나 문자열 양 끝의 공백은 토큰화 과정에서 제거된다.

## 예외와 허용/제한 정책

| 구분 | 허용한 범위 | 오류로 간주한 범위 | 근거 |
| --- | --- | --- | --- |
| 입력 문자열 | 앞뒤 공백을 포함하더라도 실제 본문이 존재하면 허용 | `null` 또는 공백 전체 입력은 즉시 오류 | `Expression.from`에서 `null`/blank 검증 수행 |
| 헤더 형식 | `//;\n1;2`와 같이 `//` 접두사와 개행을 포함한 형식만 허용 | 개행 누락, 헤더만 있고 본문이 없는 경우, `//`로 시작하지 않는 경우 | `Header.parse`에서 정규화 및 형식 검사 수행 |
| 커스텀 구분자 문자 | 알파벳(A-Z, a-z) 1~3글자 | 숫자, 특수문자, 4글자 이상, 공백 | `Delimiter`가 길이와 정규식을 검증하여 사용자 혼동을 방지하고 가독성을 유지 |
| 기본 구분자 | 쉼표, 콜론을 항상 추가로 허용 | 제거 불가 | `Delimiters.defaults`가 내부 정책으로 두 구분자를 강제 포함 |
| 구분자 연속 사용 | `1,,2`처럼 연속 구분자는 허용하며 빈 토큰은 제거 | 모든 토큰이 비어 있는 경우(본문 없음) | `Numbers.parse`에서 빈 토큰 필터링, 단 전체 본문 공백은 금지 |
| 숫자 토큰 파싱 | 양끝 공백을 허용하며 `trim` 후 정수로 변환 | 정수가 아니거나 음수 | `PositiveNumber.parse`가 공백 제거 후 정수 변환, 음수 시 `IllegalArgumentException` 발생 |
| 합산 대상 | 0 이상의 모든 정수 | 음수 | `PositiveNumber` 생성자에서 음수 차단 |

위 정책은 사용자에게 명확한 에러 메시지를 제공하고, 입력 실수를 빠르게 발견하게 하며, 확장 시 예측 가능한 형식을 유지하기 위해 설정했다.
