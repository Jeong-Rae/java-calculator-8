# java-calculator-precourse

## 요구사항 정리

* 사용자에게 콘솔에서 정수 문자열을 입력받을 수 있다.
* 사용자에게 입력받은 문자열은 `구분자`에 따라 분할된다.
* 문자열에는 `구분자`와 `양수`만 포함될 수 있다.
* 사용자는 입력 문자열 앞에 `//[구분자]\\n` 형식의 헤더를 추가하여 커스텀 구분자를 등록할 수 있다.
* 올바른 문자열 입력에 따라 얻어진 양수의 합을 반환한다.

## 개발 지향점

* 도메인 모델 객체를 중심으로, 객체의 행위를 메서드를 통해 표현한다.
* Layered Architecture를 통해 **책임별 분리와 방향성 있는 의존 관계**를 유지한다.
* 상위 레이어는 하위 레이어를 의존하지만, 하위 레이어는 상위 레이어를 의존하지 않는다.

## Layer 설정

복잡성이 낮고 외부 연동이 없는 콘솔 기반 프로그램이므로, MVC 구조를 기본으로 한 4계층 형태로 단순화한다.

---

### **View Layer**

* **역할:**
  사용자와의 입출력을 담당한다. 콘솔에서 입력을 읽고 출력한다. `Controller`가 View를 호출해 데이터를 전달받거나 사용자에게 결과를 보여 준다.
* **의존성 방향:**
  `Controller`에 의존하지 않는다. View는 독립 객체로 유지되고, `Controller`가 View를 주입 받아 호출한다.

---

### **Controller Layer**

* **역할:**
  사용자의 요청 흐름을 제어한다. View를 통해 입력을 수집하고 Service에 전달하며, 처리 결과를 다시 View에 위임해 사용자에게 보여 준다.
  예외 발생 시 사용자에게 알맞은 메시지를 출력하거나 애플리케이션 종료를 제어한다.
* **의존성 방향:**
  `View`, `Service`에 의존한다.

---

### **Service Layer**

* **역할:**
  비즈니스 로직의 흐름을 담당한다. 문자열 분리, 커스텀 구분자 처리, 숫자 파싱 및 합산과 같은 기능을 수행한다.
  도메인 모델(`Model`)을 사용하여 연산을 수행하며, 핵심 규칙과 정책을 구현한다.
* **의존성 방향:**
  `Model`에 의존한다.

---

### **Model Layer**

* **역할:**
  핵심 도메인 모델을 정의한다. 비즈니스 규칙을 스스로 보장하며, 불변성과 데이터 무결성을 유지한다.
* **의존성 방향:**
  다른 어떤 레이어에도 의존하지 않는다.

## MVC 구성요소별 흐름

1. `Application`이 `CalculatorController`를 생성하면서 `ConsoleInputView`, `ConsoleOutputView`, `CalculatorService`를 주입하고 `run()`을 호출한다.
2. `Controller`는 주입받은 `ConsoleInputView`를 호출해 문자열을 입력받는다.
3. `Controller`는 입력값을 `CalculatorService`에 전달하고, `Service`는 도메인 모델(`Expression`)을 사용해 합계를 계산한다.
4. `Controller`는 계산 결과를 주입받은 `ConsoleOutputView`에 전달해 사용자에게 출력하도록 위임한다.
5. 도메인 검증 실패 시 발생한 `IllegalArgumentException`은 `Controller`가 메시지를 출력한 뒤 다시 던져 호출 측에서 처리할 수 있게 한다.

## 도메인 모델 책임

* **Expression**: 입력 문자열을 해석하고 헤더 존재 여부에 따라 `Delimiters`와 `Numbers`를 구성한다. 기본 구분자와 커스텀 구분자를 조합해 불변 도메인 객체를 생성한다.
* **Header**: `//[구분자]\\n` 패턴을 해석한다. 개행 문자 정규화, 헤더/본문 분리, 커스텀 구분자 파싱을 담당하며 잘못된 형식을 검증한다.
* **Delimiters**: 구분자 집합을 불변으로 유지하고, 정규식 패턴을 생성해 본문 문자열을 토큰화한다. 기본 구분자(쉼표, 콜론)와 커스텀 구분자를 병합한다.
* **Delimiter**: 단일 구분자 값 객체다. 커스텀 구분자의 최대 길이, 허용 문자, 공백 여부를 검증하고, 내부 기본 구분자 생성도 책임진다.
* **Numbers**: 파싱된 `PositiveNumber` 리스트의 불변 컬렉션을 제공하고 합계를 계산한다. 입력 토큰이 비어 있지 않은지 검증한다.
* **PositiveNumber**: 개별 숫자가 0 이상의 정수인지 확인하고, 문자열 토큰을 안전하게 정수로 변환한다.

## 비즈니스 규칙

* 입력 전체는 `null`이거나 공백일 수 없다.
* 헤더가 존재하면 반드시 `//`로 시작하고 개행(`\n`)으로 종료해야 한다.
* 기본 구분자는 쉼표(`,`), 콜론(`:`)이며, 커스텀 구분자를 추가하면 기본 구분자도 함께 사용된다.
* 커스텀 구분자는 최대 3글자의 알파벳 대/소문자만 허용한다.
* 본문(body)은 비어 있을 수 없고, 허용된 구분자로 분리된 정수 토큰으로 구성되어야 한다.
* 숫자 토큰은 정수여야 하며 음수는 허용되지 않는다. 0은 허용된다.
* 연속된 구분자나 문자열 양 끝의 공백은 토큰화 과정에서 제거된다.

## 예외와 허용/제한 정책

| 구분 | 허용한 범위 | 오류로 간주한 범위 | 근거 |
| --- | --- | --- | --- |
| 입력 문자열 | 앞뒤 공백을 포함하더라도 실제 본문이 존재하면 허용 | `null` 또는 공백 전체 입력은 즉시 오류 | `Expression.from`에서 `null`/blank 검증 수행 |
| 헤더 형식 | `//;\n1;2`와 같이 `//` 접두사와 개행을 포함한 형식만 허용 | 개행 누락, 헤더만 있고 본문이 없는 경우, `//`로 시작하지 않는 경우 | `Header.parse`에서 정규화 및 형식 검사 수행 |
| 커스텀 구분자 문자 | 알파벳(A-Z, a-z) 1~3글자 | 숫자, 특수문자, 4글자 이상, 공백 | `Delimiter`가 길이와 정규식을 검증하여 사용자 혼동을 방지하고 가독성을 유지 |
| 기본 구분자 | 쉼표, 콜론을 항상 추가로 허용 | 제거 불가 | `Delimiters.defaults`가 내부 정책으로 두 구분자를 강제 포함 |
| 구분자 연속 사용 | `1,,2`처럼 연속 구분자는 허용하며 빈 토큰은 제거 | 모든 토큰이 비어 있는 경우(본문 없음) | `Numbers.parse`에서 빈 토큰 필터링, 단 전체 본문 공백은 금지 |
| 숫자 토큰 파싱 | 양끝 공백을 허용하며 `trim` 후 정수로 변환 | 정수가 아니거나 음수 | `PositiveNumber.parse`가 공백 제거 후 정수 변환, 음수 시 `IllegalArgumentException` 발생 |
| 합산 대상 | 0 이상의 모든 정수 | 음수 | `PositiveNumber` 생성자에서 음수 차단 |

위 정책은 사용자에게 명확한 에러 메시지를 제공하고, 입력 실수를 빠르게 발견하게 하며, 확장 시 예측 가능한 형식을 유지하기 위해 설정했다.
